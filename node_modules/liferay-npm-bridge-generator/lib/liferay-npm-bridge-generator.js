"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const globby_1 = __importDefault(require("globby"));
const path_1 = __importDefault(require("path"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
const yargs_1 = __importDefault(require("yargs"));
const argv = yargs_1.default
    // Whether or not to explain what's going on
    .option('verbose', {
    alias: 'v',
    default: false,
}).argv;
// Default template used to generate bridges
const defaultTemplate = `Liferay.Loader.define('{PKG_NAME}@{PKG_VERSION}/{DEST_MOD}', ['module', '{SRC_MOD}'], function (module, src) {
  module.exports = src;
});
`;
/**
 * Main entry point
 * @return {void}
 */
function main() {
    const pkgJson = read_json_sync_1.default('./package.json');
    const config = read_json_sync_1.default('./.npmbridgerc');
    Object.keys(config).forEach(key => {
        const opts = config[key];
        log(`'${key}' bridges:`);
        // Input folder where source modules live
        const input = opts['input'] || 'classes/META-INF/resources/node_modules';
        // Output folder where bridge modules must be placed
        const output = opts['output'] || 'classes/META-INF/resources/bridge';
        // The glob expression(s) to filter source modules
        const fileGlobs = opts['file-globs'] || '**/lib/**/*.js';
        // A mapper to convert source file paths to destination file paths
        const destFileMapper = opts['dest-file-mapper'] || {
            from: '(.*)\\$(.*)@.*/lib/(.*)',
            to: '$2/src/$3',
        };
        // A mapper to convert source file paths to source module names
        const srcModNameMapper = opts['src-mod-name-mapper'] || {
            from: '(.*)@[^/]*(.*)\\.js$',
            to: '$1$2',
        };
        // A mapper to convert destination file paths to destination module names
        const destModNameMapper = opts['dest-mod-name-mapper'] || {
            from: '(.*)\\.js$',
            to: 'bridge/$1',
        };
        // Template used to generate bridges
        const template = opts['template'] || defaultTemplate;
        // Go!
        globby_1.default
            .sync(fileGlobs.split(','), {
            cwd: input,
        })
            .forEach(srcFile => {
            const destFile = srcFile.replace(new RegExp(destFileMapper.from), destFileMapper.to);
            const srcMod = srcFile.replace(new RegExp(srcModNameMapper.from), srcModNameMapper.to);
            const destMod = destFile.replace(new RegExp(destModNameMapper.from), destModNameMapper.to);
            const absDestFile = path_1.default.join(output, destFile);
            let contents = template;
            contents = contents.replace('{PKG_NAME}', pkgJson.name);
            contents = contents.replace('{PKG_VERSION}', pkgJson.version);
            contents = contents.replace('{SRC_MOD}', srcMod);
            contents = contents.replace('{DEST_MOD}', destMod);
            fs_extra_1.default.mkdirsSync(path_1.default.dirname(absDestFile));
            fs_extra_1.default.writeFileSync(absDestFile, contents);
            log(srcFile, '->', destFile);
        });
    });
}
exports.default = main;
/**
 * Log a message if verbose argument is active.
 * @param  {Array} args arguments given to the function
 * @return {void}
 */
function log(...args) {
    if (argv.verbose) {
        console.log(...args);
    }
}
