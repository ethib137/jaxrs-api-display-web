"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
const path_1 = __importDefault(require("path"));
const pretty_time_1 = __importDefault(require("pretty-time"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
const semver_1 = __importDefault(require("semver"));
const dependencies_1 = require("./dependencies");
const insight = __importStar(require("./insight"));
const jar_1 = __importDefault(require("./jar"));
const log = __importStar(require("./log"));
const manifest_1 = __importDefault(require("./manifest"));
const report_1 = __importDefault(require("./report"));
const copy_1 = __importDefault(require("./steps/copy"));
const rules_1 = __importDefault(require("./steps/rules"));
const transform_1 = __importDefault(require("./steps/transform"));
/** Default entry point for the liferay-npm-bundler */
function default_1(argv) {
    const versionsInfo = project_1.default.versionsInfo;
    if (argv.version) {
        versionsInfo.forEach((value, key) => {
            console.log(`"${key}":`, JSON.stringify(value, null, 2));
        });
        return;
    }
    report_1.default.versionsInfo(versionsInfo);
    if (project_1.default.misc.noTracking) {
        run();
    }
    else {
        log.debug('The tool is sending usage statistics to our remote servers.');
        insight.init().then(run);
    }
}
exports.default = default_1;
/** Real tool execution */
function run() {
    try {
        const start = process.hrtime();
        // Get root package
        const rootPkg = dependencies_1.getRootPkg();
        report_1.default.rootPackage(rootPkg);
        // Compute dependency packages
        const depPkgsMap = dependencies_1.addPackageDependencies({}, project_1.default.dir.asNative, project_1.default.copy.includedDependencies);
        const depPkgs = Object.values(depPkgsMap).filter(pkg => !pkg.isRoot);
        report_1.default.dependencies(depPkgs);
        reportLinkedDependencies(project_1.default.pkgJson);
        // Report rules config
        report_1.default.rulesConfig(project_1.default.rules.config);
        // Warn about incremental builds
        if (manifest_1.default.loadedFromFile) {
            report_1.default.warn('This report is from an incremental build: some steps may be ' +
                'missing (you may remove the output directory to force a ' +
                'full build).');
        }
        // Do things
        copy_1.default(rootPkg, depPkgs)
            .then(() => rules_1.default(rootPkg, depPkgs))
            .then(() => transform_1.default(rootPkg, depPkgs))
            .then(() => manifest_1.default.save())
            .then(() => (project_1.default.jar.supported ? jar_1.default() : undefined))
            .then(() => {
            // Report and show execution time
            const hrtime = process.hrtime(start);
            report_1.default.executionTime(hrtime);
            log.info(`Bundling took ${pretty_time_1.default(hrtime)}`);
            // Send report analytics data
            report_1.default.sendAnalytics();
            // Write report if requested
            if (project_1.default.misc.reportFile) {
                fs_extra_1.default.writeFileSync(project_1.default.misc.reportFile.asNative, report_1.default.toHtml());
                log.info(`Report written to ${project_1.default.misc.reportFile.asNative}`);
            }
            else if (report_1.default.warningsPresent) {
                log.debug('The build has emitted some warning messages.');
            }
        })
            .catch(abort);
    }
    catch (err) {
        abort(err);
    }
}
/** Report linked dependencies of a given package.json */
function reportLinkedDependencies(pkgJson) {
    ['dependencies', 'devDependencies'].forEach(scope => {
        if (pkgJson[scope] != null) {
            Object.keys(pkgJson[scope]).forEach(depName => {
                const depVersion = pkgJson[scope][depName];
                if (semver_1.default.validRange(depVersion) == null) {
                    const depPkgJsonPath = path_1.default.join('node_modules', depName, 'package.json');
                    const depPkgJson = read_json_sync_1.default(depPkgJsonPath);
                    pkgJson[scope][depName] = depPkgJson.version;
                    report_1.default.linkedDependency(depName, depVersion, depPkgJson.version);
                }
            });
        }
    });
}
/** Abort execution after showing error message */
function abort(err) {
    log.error(`

${err.stack}

`);
    process.exit(1);
}
