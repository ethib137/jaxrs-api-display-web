"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pkg_desc_1 = __importDefault(require("liferay-npm-build-tools-common/lib/pkg-desc"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
const path_1 = __importDefault(require("path"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
const resolve_1 = __importDefault(require("resolve"));
const report_1 = __importDefault(require("./report"));
const pkgJson = project_1.default.pkgJson;
const rootPkg = new pkg_desc_1.default(pkgJson.name, pkgJson.version);
/**
 * Get root package descriptor
 * @return {PkgDesc} the root package descriptor
 */
function getRootPkg() {
    return rootPkg;
}
exports.getRootPkg = getRootPkg;
/**
 * Recursively find the dependencies of a package and return them as PkgDesc
 * objects.
 * @param {object} collectedDependencies a hash of objects where key is the
 * 					package id and values are PkgDesc objects
 * @param {string} basedirPath directory where package lives in
 * @param {Array} extraDependencies an array of package names to add to
 *					dependencies collected from package.json
 * @return {{[pkgId:string]: PkgDesc}} the given collectedDependencies object
 */
function addPackageDependencies(collectedDependencies, basedirPath, extraDependencies = []) {
    const packageJson = read_json_sync_1.default(path_1.default.join(basedirPath, '/package.json'));
    const pkg = new pkg_desc_1.default(packageJson.name, packageJson.version, path_1.default.resolve(basedirPath) == path_1.default.resolve(project_1.default.dir.asNative)
        ? null
        : basedirPath);
    if (collectedDependencies[pkg.id]) {
        return;
    }
    collectedDependencies[pkg.id] = pkg;
    let dependencies = packageJson.dependencies || {};
    dependencies = Object.keys(dependencies);
    dependencies = dependencies.concat(extraDependencies);
    const dependencyDirs = dependencies
        .map(dependency => {
        return resolveDependencyDir(basedirPath, packageJson, dependency);
    })
        .filter(dependencyDir => {
        return dependencyDir != null;
    });
    dependencyDirs.forEach(dependencyDir => {
        addPackageDependencies(collectedDependencies, dependencyDir);
    });
    return collectedDependencies;
}
exports.addPackageDependencies = addPackageDependencies;
/**
 * Resolves a dependency package and returns its directory.
 * @param {String} packageDir the base directory used for resolution
 * @param {Object} packageJson the package.json object
 * @param {String} dependency a package name
 * @return {String} the path of the directory containing the dependency package
 */
function resolveDependencyDir(packageDir, packageJson, dependency) {
    try {
        const pkgJsonFile = resolve_1.default.sync(dependency + '/package.json', {
            basedir: packageDir,
        });
        return path_1.default.dirname(pkgJsonFile);
    }
    catch (err) {
        if (packageJson.optionalDependencies &&
            packageJson.optionalDependencies[dependency]) {
            report_1.default.warn(`Optional dependency '${dependency}' of ` +
                `'${packageJson.name}' could not be found in ` +
                `node_modules: it will be missing in the output bundle.`);
            return null;
        }
        else {
            throw err;
        }
    }
}
