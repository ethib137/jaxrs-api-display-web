"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const globby_1 = __importDefault(require("globby"));
const jszip_1 = __importDefault(require("jszip"));
const file_path_1 = __importDefault(require("liferay-npm-build-tools-common/lib/file-path"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
const path_1 = __importDefault(require("path"));
const ddm = __importStar(require("./ddm"));
const xml = __importStar(require("./xml"));
const pkgJson = project_1.default.pkgJson;
/**
 * Create an OSGi bundle with build's output
 * @return {Promise}
 */
function createJar() {
    const zip = new jszip_1.default();
    addManifest(zip);
    addBuildFiles(zip);
    addLocalizationFiles(zip);
    addSystemConfigurationFiles(zip);
    addPortletInstanceConfigurationFile(zip);
    return zip.generateAsync({ type: 'nodebuffer' }).then(buffer => {
        fs_extra_1.default.mkdirpSync(project_1.default.jar.outputDir.asNative);
        fs_extra_1.default.writeFileSync(project_1.default.jar.outputDir.join(project_1.default.jar.outputFilename).asNative, buffer);
    });
}
exports.default = createJar;
/**
 * Add build's output files to ZIP archive
 * @param {JSZip} zip the ZIP file
 */
function addBuildFiles(zip) {
    addFiles(project_1.default.buildDir.asNative, ['**/*', `!${project_1.default.jar.outputFilename}`], zip.folder('META-INF').folder('resources'));
}
/**
 * Add several files to a ZIP folder.
 * @param {string} srcDirPath source folder
 * @param {array} srcGlobs array of globs describing files to include (in
 * 						globby, i.e. POSIX, format)
 * @param {JSZip} destFolder the destination folder in the ZIP file
 */
function addFiles(srcDirPath, srcGlobs, destFolder) {
    const filePaths = globby_1.default
        .sync(srcGlobs, {
        cwd: srcDirPath,
        nodir: true,
    })
        .map(posixPath => new file_path_1.default(posixPath, { posix: true }))
        .map(file => file.asNative);
    filePaths.forEach(filePath => {
        const parts = filePath.split(path_1.default.sep);
        const dirs = parts.slice(0, parts.length - 1);
        const name = parts[parts.length - 1];
        const folder = dirs.reduce((folder, dir) => folder.folder(dir), destFolder);
        folder.file(name, fs_extra_1.default.readFileSync(path_1.default.join(srcDirPath, filePath)));
    });
}
/**
 * Add the localization bundle files if configured.
 * @param {JSZip} zip the ZIP file
 */
function addLocalizationFiles(zip) {
    const languageFileBaseName = project_1.default.l10n.languageFileBaseName;
    if (languageFileBaseName) {
        const localizationDirPath = path_1.default.dirname(languageFileBaseName.asNative);
        addFiles(localizationDirPath, ['**/*'], zip.folder('content'));
    }
}
/**
 * Add the manifest file to the ZIP archive
 * @param {JSZip} zip the ZIP file
 */
function addManifest(zip) {
    let contents = '';
    const bundlerVersion = project_1.default.versionsInfo.get('liferay-npm-bundler')
        .version;
    contents += `Manifest-Version: 1.0\n`;
    contents += `Bundle-ManifestVersion: 2\n`;
    contents += `Tool: liferay-npm-bundler-${bundlerVersion}\n`;
    contents += `Bundle-SymbolicName: ${pkgJson.name}\n`;
    contents += `Bundle-Version: ${pkgJson.version}\n`;
    if (pkgJson.description) {
        contents += `Bundle-Name: ${pkgJson.description}\n`;
    }
    contents += `Web-ContextPath: ${project_1.default.jar.webContextPath}\n`;
    contents +=
        `Provide-Capability: osgi.webresource;` +
            `osgi.webresource=${pkgJson.name};` +
            `version:Version="${pkgJson.version}"\n`;
    if (project_1.default.l10n.supported) {
        const bundleName = path_1.default.basename(project_1.default.l10n.languageFileBaseName.asNative);
        contents += `Provide-Capability: liferay.resource.bundle;`;
        contents += `resource.bundle.base.name="content.${bundleName}"\n`;
    }
    if (project_1.default.jar.requireJsExtender) {
        let filter;
        const minimumExtenderVersion = getMinimumExtenderVersion();
        if (minimumExtenderVersion) {
            filter =
                `(&` +
                    `(osgi.extender=liferay.frontend.js.portlet)` +
                    `(version>=${minimumExtenderVersion})` +
                    `)`;
        }
        else {
            filter = `(osgi.extender=liferay.frontend.js.portlet)`;
        }
        contents += `Require-Capability: osgi.extender;filter:="${filter}"\n`;
    }
    Object.entries(project_1.default.jar.customManifestHeaders).forEach(([key, value]) => {
        contents += `${key}: ${value}\n`;
    });
    zip.folder('META-INF').file('MANIFEST.MF', contents);
}
/**
 * Add the settings files if configured.
 * @param {JSZip} zip the ZIP file
 */
function addSystemConfigurationFiles(zip) {
    const systemConfigJson = getSystemConfigurationJson();
    if (!systemConfigJson) {
        return;
    }
    // Add OSGI-INF/metatype/metatype.xml file
    const localization = project_1.default.l10n.supported
        ? `content/${path_1.default.basename(project_1.default.l10n.languageFileBaseName.asNative)}`
        : undefined;
    const name = systemConfigJson.name ||
        (localization ? pkgJson.name : pkgJson.description || pkgJson.name);
    const metatype = xml.createMetatype(pkgJson.name, name);
    if (localization) {
        xml.addMetatypeLocalization(metatype, localization);
    }
    const fields = Object.entries(systemConfigJson.fields);
    fields.forEach(([id, desc]) => {
        xml.addMetatypeAttr(metatype, id, desc);
    });
    zip.folder('OSGI-INF')
        .folder('metatype')
        .file(`${pkgJson.name}.xml`, xml.format(metatype));
    // Add features/metatype.json file
    const metatypeJson = {};
    if (systemConfigJson.category) {
        metatypeJson.category = systemConfigJson.category;
    }
    zip.folder('features').file('metatype.json', JSON.stringify(metatypeJson, null, 2));
}
/**
 * Add the portlet preferences file if configured.
 * @param {JSZip} zip the ZIP file
 */
function addPortletInstanceConfigurationFile(zip) {
    const portletInstanceConfigJson = getPortletInstanceConfigurationJson();
    if (!portletInstanceConfigJson) {
        return;
    }
    const ddmJson = ddm.transformPreferences(project_1.default, portletInstanceConfigJson);
    zip.folder('features').file('portlet_preferences.json', JSON.stringify(ddmJson, null, 2));
}
/**
 * Get the minimum extender version needed for the capabilities of this bundle
 * to work
 * @return {string|undefined} a version number or undefined if none is required
 */
function getMinimumExtenderVersion() {
    const requireJsExtender = project_1.default.jar.requireJsExtender;
    if (typeof requireJsExtender === 'string') {
        if (requireJsExtender === 'any') {
            return undefined;
        }
        return requireJsExtender;
    }
    let minExtenderMinorVersion = 0;
    if (getSystemConfigurationJson()) {
        minExtenderMinorVersion = Math.max(minExtenderMinorVersion, 1);
    }
    if (getPortletInstanceConfigurationJson()) {
        minExtenderMinorVersion = Math.max(minExtenderMinorVersion, 1);
    }
    return `1.${minExtenderMinorVersion}.0`;
}
/**
 * Get portlet instance configuration JSON object from getConfigurationFile()
 * file.
 * @return {object}
 */
function getPortletInstanceConfigurationJson() {
    if (!project_1.default.jar.configurationFile) {
        return undefined;
    }
    const filePath = project_1.default.jar.configurationFile.asNative;
    const configurationJson = fs_extra_1.default.readJSONSync(filePath);
    if (!configurationJson.portletInstance ||
        !configurationJson.portletInstance.fields ||
        Object.keys(configurationJson.portletInstance.fields).length == 0) {
        return undefined;
    }
    return configurationJson.portletInstance;
}
/**
 * Get system configuration JSON object from getConfigurationFile() file.
 * @return {object}
 */
function getSystemConfigurationJson() {
    if (!project_1.default.jar.configurationFile) {
        return undefined;
    }
    const filePath = project_1.default.jar.configurationFile.asNative;
    const configurationJson = fs_extra_1.default.readJSONSync(filePath);
    if (!configurationJson.system ||
        !configurationJson.system.fields ||
        Object.keys(configurationJson.system.fields).length == 0) {
        return undefined;
    }
    return configurationJson.system;
}
