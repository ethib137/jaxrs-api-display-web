"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const babel = __importStar(require("babel-core"));
const clone_1 = __importDefault(require("clone"));
const data_urls_1 = __importDefault(require("data-urls"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const babelIpc = __importStar(require("liferay-npm-build-tools-common/lib/babel-ipc"));
const gl = __importStar(require("liferay-npm-build-tools-common/lib/globs"));
const packages_1 = require("liferay-npm-build-tools-common/lib/packages");
const pkg_desc_1 = __importDefault(require("liferay-npm-build-tools-common/lib/pkg-desc"));
const plugin_logger_1 = __importDefault(require("liferay-npm-build-tools-common/lib/plugin-logger"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
const path_1 = __importDefault(require("path"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
const rimraf_1 = __importDefault(require("rimraf"));
const log = __importStar(require("../log"));
const manifest_1 = __importDefault(require("../manifest"));
const report_1 = __importDefault(require("../report"));
const util_1 = require("./util");
/**
 * Transform root and dependency packages.
 * @param {PkgDesc} rootPkg the root package descriptor
 * @param {Array<PkgDesc>} depPkgs dependency package descriptors
 * @return {Promise}
 */
function transformPackages(rootPkg, depPkgs) {
    const dirtyPkgs = [rootPkg, ...depPkgs].filter(srcPkg => !srcPkg.clean);
    return Promise.all(dirtyPkgs.map(srcPkg => transformPackage(srcPkg))).then(() => log.debug(`Transformed ${dirtyPkgs.length} packages`));
}
exports.default = transformPackages;
/**
 *
 * @param {PkgDesc} srcPkg
 * @return {Promise}
 */
function transformPackage(srcPkg) {
    if (!manifest_1.default.isOutdated(srcPkg.id)) {
        return Promise.resolve();
    }
    log.debug(`Transforming package '${srcPkg.id}'...`);
    const destPkg = srcPkg.clone({
        dir: util_1.getDestDir(srcPkg),
    });
    return runBundlerPlugins('pre', srcPkg, destPkg)
        .then(() => babelifyPackage(destPkg))
        .then(() => runBundlerPlugins('post', srcPkg, destPkg))
        .then(() => renamePkgDirIfNecessary(destPkg))
        .then(destPkg => manifest_1.default.addPackage(srcPkg, destPkg))
        .then(() => log.debug(`Transformed package '${srcPkg.id}'`));
}
/**
 * Process an NPM package with the configured liferay-nmp-bundler plugins. This
 * function is called two times (known as phases) per package: one before Babel
 * runs and one after.
 * @param {String} phase 'pre' or 'post' depending on what phase we are in
 * @param {PkgDesc} srcPkg the source package descriptor
 * @param {PkgDesc} destPkg the target package descriptor
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function runBundlerPlugins(phase, srcPkg, destPkg) {
    return new Promise((resolve, reject) => {
        try {
            const state = util_1.runPlugins(phase === 'pre'
                ? project_1.default.transform.getPrePluginDescriptors(destPkg)
                : project_1.default.transform.getPostPluginDescriptors(destPkg), srcPkg, destPkg, {
                pkgJson: read_json_sync_1.default(destPkg.dir.join('package.json').asNative),
            }, (plugin, log) => {
                report_1.default.packageProcessBundlerPlugin(phase, destPkg, plugin, log);
                if (log.errorsPresent) {
                    report_1.default.warn('There are errors for some of the ' +
                        'liferay-npm-bundler plugins: please check ' +
                        'details of bundler transformations.', { unique: true });
                }
                else if (log.warnsPresent) {
                    report_1.default.warn('There are warnings for some of the ' +
                        'liferay-npm-bundler plugins: please check ' +
                        'details of bundler transformations.', { unique: true });
                }
            });
            fs_extra_1.default.writeFileSync(destPkg.dir.join('package.json').asNative, JSON.stringify(state.pkgJson, '', 2));
            resolve();
        }
        catch (err) {
            reject(err);
        }
    });
}
/**
 * Run Babel on a package.
 * @param {PkgDesc} destPkg the package descriptor
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function babelifyPackage(destPkg) {
    // Make a copy of the package's Babel configuration
    const babelConfig = clone_1.default(project_1.default.transform.getBabelConfig(destPkg));
    // Tune babel config
    babelConfig.babelrc = false;
    babelConfig.compact = false;
    babelConfig.only = '**/*';
    if (babelConfig.sourceMaps === undefined) {
        babelConfig.sourceMaps = true;
    }
    // Report a copy of the package's Babel configuration before loading plugins
    report_1.default.packageProcessBabelConfig(destPkg, clone_1.default(babelConfig));
    // Intercept presets and plugins to load them from here
    babelConfig.plugins = project_1.default.transform.getBabelPlugins(destPkg);
    babelConfig.presets = [];
    // Determine file globs
    const globs = ['**/*.js', '!node_modules/**/*'];
    if (destPkg.isRoot) {
        globs.push(...gl.negate(project_1.default.transform.babelIgnores));
    }
    // Run babel through files
    const prjRelPaths = util_1.findFiles(project_1.default.dir.asNative, gl.prefix(`${project_1.default.dir.asPosix}/${destPkg.dir.asPosix}/`, globs));
    log.debug(`Babelifying ${prjRelPaths.length} files in package '${destPkg.id}'...`);
    return util_1.runInChunks(prjRelPaths, project_1.default.misc.maxParallelFiles, 0, prjRelPath => babelifyFile(destPkg, prjRelPath, babelConfig));
}
/**
 *
 * @param {PkgDesc} destPkg
 * @param {string} prjRelPath
 * @param {object} babelConfig
 * @return {Promise}
 */
function babelifyFile(destPkg, prjRelPath, babelConfig) {
    return new Promise(resolve => {
        const logger = new plugin_logger_1.default();
        babelIpc.set(project_1.default.dir.join(prjRelPath).asNative, {
            log: logger,
            manifest: manifest_1.default,
            rootPkgJson: clone_1.default(project_1.default.pkgJson),
            globalConfig: clone_1.default(project_1.default.globalConfig),
        });
        const fileAbsPath = project_1.default.dir.join(prjRelPath).asNative;
        const filePkgRelPath = project_1.default.dir
            .join(destPkg.dir)
            .relative(fileAbsPath).asNative;
        babel.transformFile(fileAbsPath, {
            filename: fileAbsPath,
            filenameRelative: prjRelPath,
            inputSourceMap: loadSourceMap(fileAbsPath),
            ...babelConfig,
        }, (err, result) => {
            // Generate and/or log results
            if (err) {
                logger.error('babel', err);
                report_1.default.warn('Babel failed processing some .js files: ' +
                    'check details of Babel transformations for more info.', { unique: true });
            }
            else {
                const fileName = path_1.default.basename(fileAbsPath);
                fs_extra_1.default.writeFileSync(fileAbsPath, `${result.code}\n` +
                    `//# sourceMappingURL=${fileName}.map`);
                fs_extra_1.default.writeFileSync(`${fileAbsPath}.map`, JSON.stringify(result.map));
            }
            // Report result of babel run
            report_1.default.packageProcessBabelRun(destPkg, filePkgRelPath, logger);
            if (logger.errorsPresent) {
                report_1.default.warn('There are errors for some of the ' +
                    'Babel plugins: please check details ' +
                    'of Babel transformations.', { unique: true });
            }
            else if (logger.warnsPresent) {
                report_1.default.warn('There are warnings for some of the ' +
                    'Babel plugins: please check details ' +
                    'of Babel transformations.', { unique: true });
            }
            // Get rid of Babel IPC values
            babelIpc.clear(prjRelPath);
            // Resolve promise
            resolve();
        });
    });
}
/**
 * Load the source map of a transpiled JS file.
 * @param  {string} filePath the path to the transpiled JS file
 * @return {Object|null} the source map object or null if not present
 */
function loadSourceMap(filePath) {
    const fileContent = fs_extra_1.default.readFileSync(filePath);
    const offset1 = fileContent.lastIndexOf('//# sourceMappingURL=');
    const offset2 = fileContent.lastIndexOf('/*# sourceMappingURL=');
    const offset = Math.max(offset1, offset2);
    const annotation = fileContent.toString().substring(offset);
    let matches = annotation.match(/\/\/# sourceMappingURL=(.*)/);
    if (!matches) {
        matches = annotation.match(/\/\*# sourceMappingURL=(.*) \*\//);
        if (!matches) {
            return null;
        }
    }
    const url = matches[1];
    if (url.indexOf('data:') == 0) {
        const parsedData = data_urls_1.default(url);
        if (parsedData) {
            const { body, mimeType } = parsedData;
            if (mimeType.toString() === 'application/json') {
                return JSON.parse(body.toString());
            }
        }
    }
    else {
        const sourceMapFile = path_1.default.normalize(path_1.default.join(path_1.default.dirname(filePath), url));
        try {
            return read_json_sync_1.default(sourceMapFile);
        }
        catch (err) {
            // Swallow.
        }
    }
    return null;
}
exports.loadSourceMap = loadSourceMap;
/**
 * Rename a package folder if package.json doesn't match original package name
 * or version and the package is not the root package.
 * @param {PkgDesc} destPkg the package descriptor
 * @return {Promise} resolves to the (possibly) modified `destPkg`
 */
function renamePkgDirIfNecessary(destPkg) {
    if (destPkg.isRoot) {
        return Promise.resolve(destPkg);
    }
    const pkgJson = read_json_sync_1.default(destPkg.dir.join('package.json').asNative);
    const outputDirPath = path_1.default.dirname(destPkg.dir.asNative);
    if (pkgJson.name !== destPkg.name || pkgJson.version !== destPkg.version) {
        const newDirPath = path_1.default.join(outputDirPath, packages_1.getPackageTargetDir(pkgJson.name, pkgJson.version));
        rimraf_1.default.sync(newDirPath);
        return fs_extra_1.default
            .move(destPkg.dir.asNative, newDirPath)
            .then(() => new pkg_desc_1.default(pkgJson.name, pkgJson.version, newDirPath));
    }
    return Promise.resolve(destPkg);
}
