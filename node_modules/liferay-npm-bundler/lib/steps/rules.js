"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const gl = __importStar(require("liferay-npm-build-tools-common/lib/globs"));
const plugin_logger_1 = __importDefault(require("liferay-npm-build-tools-common/lib/plugin-logger"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
const path_1 = __importDefault(require("path"));
const log = __importStar(require("../log"));
const report_1 = __importDefault(require("../report"));
const util_1 = require("./util");
/**
 * Run configured rules.
 * @param {PkgDesc} rootPkg the root package descriptor
 * @param {Array<PkgDesc>} depPkgs dependency package descriptors
 * @return {Promise}
 */
function runRules(rootPkg, depPkgs) {
    const dirtyPkgs = [rootPkg, ...depPkgs].filter(srcPkg => !srcPkg.clean);
    return Promise.all(dirtyPkgs.map(srcPkg => processPackage(srcPkg))).then(() => log.debug(`Applied rules to ${dirtyPkgs.length} packages`));
}
exports.default = runRules;
/**
 *
 * @param {PkgDesc} srcPkg
 * @param {number} chunkIndex
 * @return {Promise}
 */
function processPackage(srcPkg) {
    log.debug(`Applying rules to package '${srcPkg.id}'...`);
    const sourceGlobs = srcPkg.isRoot
        ? project_1.default.sources.map(source => fs_extra_1.default.statSync(project_1.default.dir.join(source).asNative).isDirectory()
            ? `${source.asPosix}/**/*`
            : source.asPosix)
        : ['**/*'];
    const globs = [...sourceGlobs, '!node_modules/**/*'];
    const sourcePrjRelPaths = util_1.findFiles(project_1.default.dir.asNative, gl.prefix(`${project_1.default.dir.asPosix}/${srcPkg.dir.asPosix}/`, globs));
    const destPkg = srcPkg.clone({
        dir: util_1.getDestDir(srcPkg),
    });
    return util_1.runInChunks(sourcePrjRelPaths, project_1.default.misc.maxParallelFiles, 0, prjRelPath => processFile(srcPkg, destPkg, prjRelPath));
}
/**
 *
 * @param {PkgDesc} srcPkg
 * @param {PkgDesc} destPkg
 * @param {string} prjRelPath
 * @return {Promise}
 */
function processFile(srcPkg, destPkg, prjRelPath) {
    const loaders = project_1.default.rules.loadersForFile(prjRelPath);
    if (loaders.length == 0) {
        return Promise.resolve();
    }
    const fileAbsPath = project_1.default.dir.join(prjRelPath).asNative;
    const context = {
        content: fs_extra_1.default.readFileSync(fileAbsPath),
        filePath: prjRelPath,
        extraArtifacts: {},
        log: new plugin_logger_1.default(),
    };
    return runLoaders(loaders, 0, context)
        .then(() => writeLoadersResult(srcPkg, destPkg, context))
        .then(() => report_1.default.rulesRun(prjRelPath, context.log));
}
/**
 * Run rule loaders contained in an array starting at given index.
 * @param {Array<object>} loaders
 * @param {number} firstLoaderIndex
 * @param {object} context the context object to pass to loaders
 * @return {Promise}
 */
function runLoaders(loaders, firstLoaderIndex, context) {
    if (firstLoaderIndex >= loaders.length) {
        return Promise.resolve(context.content);
    }
    const loader = loaders[firstLoaderIndex];
    const encoding = loader.metadata.encoding;
    let result;
    try {
        transformContents(true, context, encoding);
        result = loader.exec(context, loader.options);
    }
    catch (err) {
        err.message = `Loader '${loader.use}' failed: ${err.message}`;
        throw err;
    }
    return Promise.resolve(result).then(content => {
        if (content !== undefined) {
            context = Object.assign(context, { content });
        }
        transformContents(false, context, encoding);
        return runLoaders(loaders, firstLoaderIndex + 1, context);
    });
}
/**
 * Transform the contents (`content` and `extraArtifacts` value fields) from
 * Buffer to string with given `encoding` or the opposite way.
 * @param {boolean} beforeInvocation true if called before invoking the loader
 * @param {object} context
 * @param {string} encoding
 */
function transformContents(beforeInvocation, context, encoding) {
    const { extraArtifacts, filePath } = context;
    if (beforeInvocation) {
        assertBuffer(context, 'content', filePath);
        Object.keys(extraArtifacts).forEach(key => {
            assertBuffer(extraArtifacts, key, `extra artifact ${key}`);
        });
        if (encoding === null) {
            return;
        }
        if (context.content !== undefined) {
            context.content = context.content.toString(encoding);
        }
        Object.keys(extraArtifacts).forEach(key => {
            if (extraArtifacts[key] !== undefined) {
                extraArtifacts[key] = extraArtifacts[key].toString(encoding);
            }
        });
    }
    else if (encoding === null) {
        assertBuffer(context, 'content', filePath);
        Object.keys(extraArtifacts).forEach(key => {
            assertBuffer(extraArtifacts, key, `extra artifact ${key}`);
        });
    }
    else {
        assertString(context, 'content', filePath);
        Object.keys(extraArtifacts).forEach(key => {
            assertString(extraArtifacts, key, `extra artifact ${key}`);
        });
        if (context.content !== undefined) {
            context.content = Buffer.from(context.content, encoding);
        }
        Object.keys(extraArtifacts).forEach(key => {
            if (extraArtifacts[key] !== undefined) {
                extraArtifacts[key] = Buffer.from(extraArtifacts[key], encoding);
            }
        });
    }
}
exports.transformContents = transformContents;
/**
 * Assert that a given artifact content is of type `Buffer` and throw otherwise.
 * @param {object} object
 * @param {string} field
 * @param {string} what
 */
function assertBuffer(object, field, what) {
    if (object[field] === undefined) {
        return;
    }
    if (!(object[field] instanceof Buffer)) {
        throw new Error(`Expected content of ${what} to be a Buffer but was ` +
            `${typeof object[field]}`);
    }
}
/**
 * Assert that a given artifact content is of type `string` and throw otherwise.
 * @param {object} object
 * @param {string} field
 * @param {string} what
 */
function assertString(object, field, what) {
    if (object[field] === undefined) {
        return;
    }
    if (typeof object[field] !== 'string') {
        throw new Error(`Expected content of ${what} to be a string but was ` +
            `${typeof object[field]}`);
    }
}
/**
 *
 * @param {PkgDesc} srcPkg
 * @param {PkgDesc} destPkg
 * @param {object} context
 */
function writeLoadersResult(srcPkg, destPkg, context) {
    if (context.content != undefined) {
        writeRuleFile(destPkg, srcPkg.dir.relative(project_1.default.dir.join(context.filePath)).asNative, context.content);
    }
    Object.entries(context.extraArtifacts).forEach(([extraPrjRelPath, content]) => {
        if (content == undefined) {
            return;
        }
        writeRuleFile(destPkg, srcPkg.dir.relative(project_1.default.dir.join(extraPrjRelPath)).asNative, content);
        context.log.info('liferay-npm-bundler', `Rules generated extra artifact: ${extraPrjRelPath}`);
    });
}
/**
 * Write a file generated by a rule for a given destination package.
 * @param {PkgDesc} destPkg
 * @param {string} pkgRelPath
 * @param {string} content
 */
function writeRuleFile(destPkg, pkgRelPath, content) {
    if (destPkg.isRoot) {
        pkgRelPath = stripSourceDir(pkgRelPath);
    }
    const fileAbsPath = project_1.default.dir.join(destPkg.dir, pkgRelPath).asNative;
    fs_extra_1.default.ensureDirSync(path_1.default.dirname(fileAbsPath));
    fs_extra_1.default.writeFileSync(fileAbsPath, content);
}
/**
 * String configured source prefixes from package file path.
 * @param {string} pkgRelPath
 */
function stripSourceDir(pkgRelPath) {
    pkgRelPath = `.${path_1.default.sep}${pkgRelPath}`;
    for (const sourcePath of project_1.default.sources.map(source => source.asNative)) {
        const prefixPath = `${sourcePath}${path_1.default.sep}`;
        if (pkgRelPath.startsWith(prefixPath)) {
            return pkgRelPath.substring(prefixPath.length);
        }
    }
    return pkgRelPath;
}
exports.stripSourceDir = stripSourceDir;
