"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const gl = __importStar(require("liferay-npm-build-tools-common/lib/globs"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
const path_1 = __importDefault(require("path"));
const log = __importStar(require("../log"));
const manifest_1 = __importDefault(require("../manifest"));
const report_1 = __importDefault(require("../report"));
const util_1 = require("./util");
/**
 * Copy root and dependency packages to output directory.
 * @param {PkgDesc} rootPkg the root package descriptor
 * @param {Array<PkgDesc>} depPkgs dependency package descriptors
 * @return {Promise}
 */
function copyPackages(rootPkg, depPkgs) {
    const pkgs = [rootPkg, ...depPkgs];
    return Promise.all(pkgs.map(srcPkg => copyPackage(srcPkg))).then(() => log.debug(`Copied ${pkgs.filter(pkg => !pkg.clean).length} packages`));
}
exports.default = copyPackages;
/**
 *
 * @param {PkgDesc} srcPkg
 * @return {Promise}
 */
function copyPackage(srcPkg) {
    const destPkg = srcPkg.clone({
        dir: util_1.getDestDir(srcPkg),
    });
    if (!manifest_1.default.isOutdated(destPkg)) {
        return Promise.resolve();
    }
    log.debug(`Copying package '${srcPkg.id}'...`);
    srcPkg.clean = false;
    const srcPkgRelPaths = srcPkg.isRoot
        ? ['package.json']
        : util_1.findFiles(project_1.default.dir.join(srcPkg.dir).asNative, gl.prefix(`${project_1.default.dir.asPosix}/${srcPkg.dir.asPosix}/`, [
            `**/*`,
            `!node_modules/**/*`,
        ]));
    const srcPkgRelPathsToCopy = srcPkg.isRoot
        ? srcPkgRelPaths
        : runCopyPlugins(srcPkg, destPkg, util_1.findFiles(project_1.default.dir.join(srcPkg.dir).asNative, gl.prefix(`${project_1.default.dir.asPosix}/${srcPkg.dir.asPosix}/`, [
            `**/*`,
            `!node_modules/**/*`,
            ...gl.negate(project_1.default.copy.getExclusions(srcPkg)),
        ])));
    report_1.default.packageCopy(srcPkg, srcPkgRelPaths, srcPkgRelPathsToCopy);
    if (srcPkgRelPathsToCopy.length === 0) {
        srcPkg.clean = true;
    }
    return Promise.all(srcPkgRelPathsToCopy.map(srcPkgRelPath => copyFile(srcPkg, destPkg, srcPkgRelPath)));
}
/**
 * Run liferay-nmp-bundler copy plugins on a specified package.
 * @param {PkgDesc} srcPkg the source package descriptor
 * @param {PkgDesc} destPkg the target package descriptor
 * @param {Array<string>} srcPkgRelPaths the files to be processed (relative to
 * 							`srcPkg.dir`)
 * @return {Array<string>} the filtered files
 */
function runCopyPlugins(srcPkg, destPkg, srcPkgRelPaths) {
    const state = util_1.runPlugins(project_1.default.copy.getPluginDescriptors(destPkg), srcPkg, destPkg, {
        files: srcPkgRelPaths,
    }, (plugin, log) => {
        report_1.default.packageProcessBundlerPlugin('copy', destPkg, plugin, log);
    });
    return state.files;
}
/**
 *
 * @param {PkgDesc} srcPkg
 * @param {PkgDesc} destPkg
 * @param {string} srcPkgRelPath
 * @return {Promise}
 */
function copyFile(srcPkg, destPkg, srcPkgRelPath) {
    const absSrcFilePath = project_1.default.dir.join(srcPkg.dir, srcPkgRelPath).asNative;
    const absDestFilePath = project_1.default.dir.join(destPkg.dir, srcPkgRelPath)
        .asNative;
    return fs_extra_1.default
        .mkdirp(path_1.default.dirname(absDestFilePath))
        .then(() => fs_extra_1.default.copyFile(absSrcFilePath, absDestFilePath));
}
