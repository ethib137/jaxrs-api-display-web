"use strict";
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const mod = __importStar(require("./modules"));
/**
 * Test if a module name is namespaced according to any root package.
 * @param moduleName a module name
 * @return true if the module is namespaced
 */
function isNamespaced(moduleName) {
    return getNamespace(moduleName) != null;
}
exports.isNamespaced = isNamespaced;
/**
 * Namespace a module name according to some root package name. If the module
 * name is already namespaced with a different root package, an Error is thrown.
 * If the module is local it is left untouched.
 * @param moduleName a module name
 * @param name name of root package
 * @param allowOverride don't fail when trying to change the namespace
 * @return the namespaced module name
 */
function addNamespace(moduleName, { name }, { allowOverride = false } = {}) {
    const moduleNamespace = getNamespace(moduleName);
    const namespace = makeNamespace({ name });
    if (moduleNamespace != null) {
        if (moduleNamespace !== namespace) {
            if (!allowOverride) {
                throw new Error(`Current moduleName namespace (${moduleNamespace}) ` +
                    ` and given one (${namespace}) don't match`);
            }
            else {
                moduleName = removeNamespace(moduleName);
            }
        }
        else {
            return moduleName;
        }
    }
    if (mod.isLocalModule(moduleName)) {
        return moduleName;
    }
    else if (moduleName.startsWith(`${name}/`) || moduleName === name) {
        return moduleName;
    }
    else if (moduleName.startsWith('@')) {
        return moduleName.replace('@', `@${namespace}`);
    }
    else {
        return namespace + moduleName;
    }
}
exports.addNamespace = addNamespace;
/**
 * Remove namespace from a module name if present, otherwise leave it untouched.
 * @param moduleName a module name
 * @return the un-namespaced module name
 */
function removeNamespace(moduleName) {
    const namespace = getNamespace(moduleName);
    if (namespace != null) {
        if (moduleName.startsWith('@')) {
            return moduleName.replace(`@${namespace}`, '@');
        }
        else {
            return moduleName.substring(namespace.length);
        }
    }
    return moduleName;
}
exports.removeNamespace = removeNamespace;
/**
 * Returns the namespace of a given moduleName or null if module name is not
 * namespaced.
 * @param moduleName a module name
 * @return the namespace of the module name or null
 */
function getNamespace(moduleName) {
    const parts = moduleName.split('$');
    if (parts.length >= 2 && !parts[0].includes('/')) {
        if (parts[0].startsWith('@')) {
            return parts[0].substring(1) + '$';
        }
        else {
            return parts[0] + '$';
        }
    }
    return null;
}
exports.getNamespace = getNamespace;
/**
 * Compose the namespace of a module according to some root package name.
 * @param name name of root package
 * @return the namespace for modules
 */
function makeNamespace({ name }) {
    return name + '$';
}
exports.makeNamespace = makeNamespace;
